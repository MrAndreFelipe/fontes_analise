3.9.2	Testes de Integração
A medição de cobertura de código através de pytest-cov fornece métricas quantitativas da abrangência dos testes, indicando quais linhas, branches e funções são exercitadas durante execução da suite. O sistema alcança cobertura superior a 90% nos módulos críticos de segurança e lógica de negócio conforme reportado no README.md (linhas 295-299): LGPDQueryClassifier atinge 95% de cobertura validando classificação em todos os cenários operacionais incluindo casos extremos e padrões complexos, SQLValidator alcança 98% assegurando que validações de segurança são completamente testadas cobrindo todos os vetores de SQL injection conhecidos e MessageHandler obtém 94% garantindo robustez no processamento de mensagens e tratamento de erros através de múltiplas condições de payload. A meta estabelecida é manter cobertura acima de 80% balanceando custo-benefício: cobertura inferior indica testes insuficientes e alto risco de regressões, cobertura excessivamente alta (>95%) tipicamente requer esforço desproporcional testando casos extremamente improváveis sem ganho significativo de confiabilidade.
Complementando suite de testes automatizados, sistema inclui scripts de validação manual no diretório tests/manual/ que exercitam interações reais com sistemas externos onde automação completa seria excessivamente frágil ou custosa. O script test_oracle_connection_quick.py valida conectividade com Oracle Database estabelecendo conexão usando cx_Oracle, executando query simples SELECT 1 FROM DUAL e verificando retorno de resultados, identificando rapidamente problemas de rede, credenciais incorretas ou configuração TNS inválida que impediriam operação da rota Text-to-SQL. O script test_chunks_search.py exercita busca vetorial completa incluindo geração de embedding via OpenAI API através de text-embedding-3-small, consulta PostgreSQL com operador de distância cosseno (<=> implementado por extensão pgvector) aplicando threshold de similaridade mínima de 0.2 e formatação de resultados ordenados por relevância, validando pipeline completo de busca semântica desde embedding até recuperação. O script test_embedding_fallback.py simula cenário de falha da rota Text-to-SQL forçando erro ou indisponibilidade do Oracle, verificando que sistema degrada graciosamente ativando fallback automático para busca vetorial (linhas 245-254 do rag_engine.py) e mantendo funcionalidade parcial mesmo quando componente primário está indisponível, demonstrando resiliência arquitetural. Aqui também Acho que em casos acima é interessante colocar exemplo de código e o próprio teste
Estes testes manuais são executados interativamente por desenvolvedores durante deployment em novos ambientes, troubleshooting de produção quando usuários reportam problemas ou após modificações estruturais que afetam integração entre componentes. Embora não integrados em pipeline CI/CD automatizado devido a dependências de serviços externos configurados e custos de execução, servem como validação rápida de sanidade verificando que conexões estão funcionais e componentes principais respondem adequadamente. Documentação em README.md fornece instruções detalhadas para execução incluindo configuração de ambiente necessária, interpretação de saídas esperadas distinguindo sucesso de falha e troubleshooting de falhas comuns como ORA-12541 (listener inativo), ORA-12154 (service name incorreto) ou erros 401 de OpenAI (API key inválida).
